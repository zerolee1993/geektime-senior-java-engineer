{"./":{"url":"./","title":"大纲","keywords":"","body":"大纲 Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-26 14:38:36 "},"markdown/00-homework/pref-task.html":{"url":"markdown/00-homework/pref-task.html","title":"项目性能优化 TODO","keywords":"","body":"项目性能测试报告 01-测试目的 主要是让开发者对hero_mall项目的性能负载和容量有个准确的认知。同时，协助技术管理者更好的管 理业务系统性能质量，科学评估业务系统的负荷，拒绝盲目上线。 02-测试工具 03-测试环境 04-测试场景 05-核心接口的测试结果 06-测试结论 hero_web性能测试是针对重点功能，单机单节点服务进行压测，可以看到各个接口容量。本测试供给大 家作为参考，如有不足或偏差，请指正！如果对性能有其他需求，可以进行集群扩容。例如:3节点、10 节点、100节点... 地址：https://open2.hero.comvipcourse/order/{orderNo}1 Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-11 00:15:03 "},"markdown/00-homework/jvm-task.html":{"url":"markdown/00-homework/jvm-task.html","title":"JVM 虚拟机 TODO","keywords":"","body":"题目 01 请你用自己的语言介绍 Java 运行时数据区（内存区域） 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存 堆 在虚拟机启动时建立，用于存放 Java 对象、数组与运行时常量 所有线程共享 虚拟机管理最大的，也是垃圾回收的主要区域 2. 为什么堆内存要分年轻代和老年代？ 题目 02 描述一个 Java 对象的生命周期 解释一个对象的创建过程 解释一个对象的内存分配 解释一个对象的销毁过程 对象的 2 种访问方式是什么？ 为什么需要内存担保？ 题目 03 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？ ParNew 收集器 ParallelScavenge 收集器 ParallelOld 收集器 CMS 收集器 G1 收集器 Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-22 16:25:38 "},"markdown/01-java/pref.html":{"url":"markdown/01-java/pref.html","title":"项目性能优化","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-10 23:42:17 "},"markdown/01-java/jvm.html":{"url":"markdown/01-java/jvm.html","title":"JVM 虚拟机","keywords":"","body":" JVM基本常识 什么是 JVM Java 技术体系 JVM 架构图 Java 和 JVM 的关系 类加载子系统 类加载的时机 类加载的过程 类加载器 类加载的机制 运行时数据区 整体构成 虚拟机栈 本地方法栈 程序计数器 堆 方法区 字符串常量池 直接内存 对象的创建流程 与内存分配 整体过程 对象内存分配的方式 对象内存分配的安全问题 对象内存分配的过程 对象的内存布局 对象的访问 垃圾收集器 垃圾的定义 不可达对象，通过根对象进行引用搜索，最终没有被引用到的对象 垃圾定位算法 引用计数法 无法解决循环依赖的问题 根可达算法 通过 GCRoots 作为对象起点向下搜索，当一个对象到 GCRoots 没有任何引用链是，此对象是垃圾 引用链 ReferenceChain：GCRoots 走过的路径 GCRoots 虚拟机栈的栈帧中的本地变量表引用的对象 方法区中，类静态属性引用的对象 方法区中，常量引用的对象 本地方法栈中，JNI 引用的对象 虚拟机内部的引用 垃圾回收过程 第一次标记:如果对象可达性分析后，发现没有与GC Roots 相连接的引用链，那它将会被第一次标记 第二次标记:第一次标记后，接着会进行一次筛选。筛选条件:此对象是否有必要执行 finalize() 方法。在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记 第二次标记成功的对象将真的会被回收，如果失败则继续存活 案例 对象引用类型 引用分类 使用方式 案例 垃圾回收算法 复制算法 Copying 存在空间的浪费 标记清除算法 Mark-Sweep 执行效率不稳定 产生大量空间碎片 标记整理算法 Mark-Compact 垃圾收集器 串行收集器 并行收集器 JVM调优工具 调优实战 推荐资料 《Java 虚拟机规范 周志明》 课程大纲 JVM基本常识 程序执行方式 JVM整体架构 JVM5大数据区 JVM加载机制剖析 Class类 类加载子系统 类加载器 双亲委派 自定义类加载器 ClassLoader源码分析 垃圾回收算法 Parallel、Serial、CMS、G1、ZGC 垃圾收集器剖析 JVM核心参数 JVM常用指令 jps、jstat、jinfo、jhat、jmap JVM调优工具 VisualVM、GC Easy、PerfMa、MAT GC日志分析 GC日志分析工具 Minor GC、Major GC和Full GC 内存溢出与泄露案例 检测死锁案例 JVM调优实战 堆内存和元空间优化、堆栈优化、吞吐量优先策略、响应时间优先策略 Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-24 20:02:07 "},"markdown/01-java/jvm-01.html":{"url":"markdown/01-java/jvm-01.html","title":"1.JVM 基本常识","keywords":"","body":"1.1 什么是 JVM? 广义上指的是一种规范 狭义上的是JDK中的JVM虚拟机 JVM 是由各个厂商来实现，比如hotspot 1.2 Java 技术体系 Java程序设计语言 Java类库API 来自商业机构和开源社区的第三方Java类库(Google\\Apached等) Java虚拟机，各种硬件平台上的Java虚拟机实现 1.3 JVM 架构图 1.4 Java 和 JVM 的关系 JVM是宿主，Java 开发的程序则寄生在宿主上 Java，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员 Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-27 19:07:11 "},"markdown/01-java/jvm-02.html":{"url":"markdown/01-java/jvm-02.html","title":"2.类加载子系统","keywords":"","body":"2.1 类加载的时机 遇到 new、getstatic、putstatic 和 invokestatic 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化 public class Student{ private static int age ; public static void method(){} } //Student.age //Student.method(); //new Student(); 使用 java.lang.reflect 包方法时对类进行反射调用的时候 Class c = Class.forname(\"com.hero.Student\"); 初始化一个类的时候发现其父类还没初始化，要先初始化其父类 当虚拟机开始启动时，用户需要指定一个主类(main)，虚拟机会先执行这个主类的初始化 2.2 类加载的过程 类加载步骤 全限定名称>>>二进制字节流加载 class 文件 字节流的静态数据结构>>>方法区的运行时数据结构 创建字节码 Class 对象 类加载途径 jar/war jsp 生成的 class 数据库中的二进制字节流 网络中的二进制字节流 动态代理生成的二进制字节流 类的生命周期 2.3 类加载器 启动类加载器 Bootstrap ClassLoader 负责加载 JAVA_HOME\\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被虚拟机认可(按文件名识别，如 rt.jar)的类 由 C++ 实现，不是 ClassLoader 的子类 扩展类加载器 Extension ClassLoader 负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库 应用程序类加载器 Application ClassLoader 负责加载用户路径(classpath)上的类库 自定义类加载器 User ClassLoader 加载应用程序之外的类文件 在汽车行驶的时候，为汽车更换轮子 案例：JRebel 自定义类加载器案例 新建一个 User.java 类 public class User { public void print() { System.out.println(\"****User****\"); } } 将类 copy 到目录 /Users/lishaofei/Downloads 编译类： javac User.java 自定义类加载器，继承 ClassLoader，重写 findClass() 方法，调用 defineClass() 方法 package com.zero.snippet.jvm; import java.io.*; import java.lang.reflect.Method; /** * 自定义类加载器案例 * * @author lishaofei * @date 2022/9/12 11:31 */ public class MyCustomClassLoader extends ClassLoader { private final String classpath; public MyCustomClassLoader(String classpath) { this.classpath = classpath; } public static void main(String[] args) throws Exception { //自定义类加载器的加载路径(事先在该目录使用同版本 jdk 编译一个 class 类，参考 model.User) MyCustomClassLoader myCustomClassLoader = new MyCustomClassLoader(\"/Users/lishaofei/Downloads\"); // 类全限定名称 Class c = myCustomClassLoader.loadClass(\"User\"); if (c != null) { // 创建对象 Object obj = c.newInstance(); // 获取对象的指定方法 Method method = c.getMethod(\"print\", (Class[]) null); // 执行方法 method.invoke(obj); // 打印该类的类加载器 System.out.println(c.getClassLoader().toString()); // 打印内容：com.zero.snippet.jvm.MyCustomClassLoader@2f2c9b19 } } @Override protected Class findClass(String name) throws ClassNotFoundException { try { // 输入流，通过类的全限定名称加载文件到字节数组 // 将文件目录中的 class 文件，以字节码流输入内存 byte[] classDate = getData(name); if (classDate != null) { //defineClass方法将字节数组数据 转为 字节码对象 return defineClass(name, classDate, 0, classDate.length); } } catch (IOException e) { e.printStackTrace(); } return super.findClass(name); } //加载类的字节码数据 private byte[] getData(String className) throws IOException { String path = classpath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try (InputStream in = new FileInputStream(path); ByteArrayOutputStream out = new ByteArrayOutputStream()) { byte[] buffer = new byte[2048]; int len; while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); } return out.toByteArray(); } catch (FileNotFoundException e) { e.printStackTrace(); } return null; } } 执行自定义类加载器的 main 方法 输出结果如下 ****User**** com.zero.snippet.jvm.MyCustomClassLoader@3b81a1bc 2.4 类加载的机制 自底向上：检查类是否被加载，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次 自定向下：执行加载，由上层来逐层尝试加载此类，防篡改 Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-28 09:53:25 "},"markdown/01-java/concurrent.html":{"url":"markdown/01-java/concurrent.html","title":"多线程与并发编程","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-10 23:42:33 "},"markdown/01-java/socket.html":{"url":"markdown/01-java/socket.html","title":"网络编程","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-10 23:42:36 "},"markdown/02-database/mysql.html":{"url":"markdown/02-database/mysql.html","title":"MySQL 进阶","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-26 14:56:42 "},"markdown/02-database/store.html":{"url":"markdown/02-database/store.html","title":"海量数据存储与优化","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-26 14:56:57 "},"markdown/02-database/mongodb.html":{"url":"markdown/02-database/mongodb.html","title":"MongoDB","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-26 14:57:49 "},"markdown/02-database/fastdfs.html":{"url":"markdown/02-database/fastdfs.html","title":"FastDFS","keywords":"","body":"Copyright © zerolee 2022 all right reserved，powered by Gitbook修订时间： 2022-09-26 14:56:50 "}}